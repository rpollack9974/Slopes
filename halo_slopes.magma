function slopes_on_rim(p,comp)
    K := CyclotomicField((p-1)*p);
	G := DirichletGroup(p^2,K);
	psi := G.1;
	chi = psi^(p-1);
    OK := RingOfIntegers(K);
	pp := Factorization(p*OK)[1][1];
	e := RamificationDegree(pp);
	omega := psi^p;
	r := 0;
    while Valuation(omega(a)^r-a,pp) eq 0 do
        r := r+1;
    end while;
	omega := omega^r;
	
    seeds:= [];
	for j in [0..(p-3)/2] do
		print "Computing the ",j,"-th modular symbol space";
		M := ModularSymbols((chi*omega^(-2*j),2,1,base_ring=K).cuspidal_subspace();
		print "---computing Hecke";
		f := Hecke_polynomial(M,p);
        NP := NewtonPolygon(f,pp);
        seeds := seeds cat slopes_of_NP(NP);
        print slopes_of_NP(NP);
    end for;


//		v = [(j-v[a]) for a in range(len(v))]
//#		print "shifted",v
//		v = [v[a]*(p-1) for a in range(len(v))]
//#		print "scaled",v 
//		slopes = slopes + v
//		slopes.sort()
//#		print "Slopes so far:",slopes
	

//    slopes := [];
//    for a in [1..(p-1)/2] do
//        slopes := slopes cat [a*(p-1)]; //eisenstein stuff
//    end for;

	return seeds;
end function;
