function slopes_on_rim(p,comp)
    K := CyclotomicField((p-1)*p);
    G := DirichletGroup(p^2,K);
    psi := G.1;
    chi := psi^(p-1);
    OK := RingOfIntegers(K);
    print "Factoring ",p;    
    pp := Factorization(p*OK)[1][1];
    e := RamificationDegree(pp);
    omega := psi^p;
    print "Finding omega";
    r := 0;
    vals := [];
    for a in [1..p-1] do
        vals := vals cat [Valuation(omega(a)^r-a,pp)];
    end for;
    mv := Min(vals);
    while mv eq 0 do
        vals := [];    
        r := r+1;
        for a in [1..p-1] do
            vals := vals cat [Valuation(omega(a)^r-a,pp)];
        end for;
        mv := Min(vals);
    end while;
	omega := omega^r;
	
    seeds:= [];
	for j in [0..(p-3)/2] do
		print "Computing the ",j,"-th modular symbol space";
		M := CuspidalSubspace(ModularSymbols(chi*omega^(-2*j),2,1));
		print "---computing Hecke";
		f := HeckePolynomial(M,p);
        NP := NewtonPolygon(f,pp);
        seeds := seeds cat [slopes_of_NP(NP)];
        print slopes_of_NP(NP);
    end for;


//		v = [(j-v[a]) for a in range(len(v))]
//#		print "shifted",v
//		v = [v[a]*(p-1) for a in range(len(v))]
//#		print "scaled",v 
//		slopes = slopes + v
//		slopes.sort()
//#		print "Slopes so far:",slopes
	

//    slopes := [];
//    for a in [1..(p-1)/2] do
//        slopes := slopes cat [a*(p-1)]; //eisenstein stuff
//    end for;

	return seeds;
end function;
